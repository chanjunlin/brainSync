"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fast_xml_parser_1 = __importDefault(require("fast-xml-parser"));
const oracle_1 = __importDefault(require("../lib/oracle"));
const parse_json_1 = __importDefault(require("../lib/parse-json"));
const LIST_PROMPT = `**File Name List Extractor**

Your job is to examine a Markdown document that contains a mixture of text and
suggested code changes.

You should list the names of all the files that have suggested changes in the file.

Your response should be a JSON list of file names.

**Example input**

Content:
\`\`\`python
# add_one.py
def add_one(x):
  return x + 1
\`\`\`

\`\`\`\`python
# subtract_one.py
def subtract_one(x):
  return x - 1
\`\`\`

Example output:
[
  "add_one.py",
  "subtract_one.py"
]
`;
class FileChangeExtractorService {
    constructor(history, modelName, temperature) {
        this.history = history;
        this.modelName = modelName;
        this.temperature = temperature;
    }
    listFiles(clientRequest, chatHistory) {
        return __awaiter(this, void 0, void 0, function* () {
            const messages = FileChangeExtractorService.buildMessages(clientRequest, chatHistory);
            if (!messages) {
                this.history.log('[file-change-extractor] No messages found for listFiles');
                return [];
            }
            const oracle = new oracle_1.default('List files', LIST_PROMPT, this.modelName, this.temperature);
            const fileList = yield oracle.ask(messages);
            if (!fileList) {
                this.history.log('[file-change-extractor] Failed to list files');
                return undefined;
            }
            return (0, parse_json_1.default)(fileList);
        });
    }
    extractFile(clientRequest, chatHistory, fileName) {
        const messages = FileChangeExtractorService.buildMessages(clientRequest, chatHistory);
        if (!messages) {
            this.history.log('[file-change-extractor] No messages found for use by extractFile');
            return undefined;
        }
        // Extract <change> tags from the messages. Sort into reverse order, so that the most
        // recently emitted tags are primary.
        const content = FileChangeExtractorService.collectContent(messages);
        const changes = FileChangeExtractorService.extractChanges(content).reverse();
        // Return all changes that apply to the requested file name.
        const fileChanges = changes.filter((change) => change.file === fileName);
        if (fileChanges.length === 0) {
            this.history.log(`No suggested changes found for ${fileName}`);
            return undefined;
        }
        this.history.log(`[file-change-extractor] ${fileChanges.length} suggested changes found for ${fileName}`);
        return fileChanges;
    }
    static extractChanges(content) {
        // Search for <change> tags
        const changeRegex = /<change>([\s\S]*?)<\/change>/gi;
        let match;
        const changes = new Array();
        // Trim at most one leading and trailing blank lines
        const trimChange = (change) => change.replace(/^\s*\n/, '').replace(/\n\s*$/, '');
        // eslint-disable-next-line no-cond-assign
        while ((match = changeRegex.exec(content)) !== null) {
            const change = match[1];
            const parser = new fast_xml_parser_1.default.XMLParser();
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const jObj = parser.parse(change);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (jObj && jObj.file && jObj.original && jObj.modified) {
                const update = jObj;
                update.original = trimChange(update.original);
                update.modified = trimChange(update.modified);
                changes.push(jObj);
            }
        }
        return changes;
    }
    static collectContent(messages) {
        return messages
            .filter((m) => m.role === 'assistant' || m.role === 'user')
            .map((m) => m.content)
            .join('\n\n');
    }
    static buildMessages(clientRequest, chatHistory) {
        const history = [...(chatHistory || [])];
        if (clientRequest.question) {
            history.push({
                content: clientRequest.question,
                role: 'user',
            });
        }
        if (clientRequest.codeSelection) {
            history.push({
                content: clientRequest.codeSelection,
                role: 'user',
            });
        }
        return history.length > 0 ? history : undefined;
    }
}
exports.default = FileChangeExtractorService;
