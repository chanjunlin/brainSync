"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const assert_1 = __importDefault(require("assert"));
const fs_1 = require("fs");
function findLineMatch(haystack, needle) {
    const trimmed = needle.map((s) => s.trim()).filter((s) => s); // skip blank lines
    (0, assert_1.default)(trimmed.length && haystack.length);
    let needlePos = 0;
    let start = 0;
    for (let i = 0; i < haystack.length; i += 1) {
        const hay = haystack[i].trim();
        // skip blank lines
        if (hay) {
            if (trimmed[needlePos] !== hay)
                needlePos = 0;
            if (trimmed[needlePos] === hay) {
                if (!needlePos)
                    start = i;
                needlePos += 1;
                if (needlePos === trimmed.length)
                    return [start, i - start + 1];
            }
        }
    }
    return undefined;
}
function makeWhitespaceAdjuster(to, from) {
    var _a, _b;
    const fromWhitespace = (_a = from.match(/^\s*/)) === null || _a === void 0 ? void 0 : _a[0];
    const toWhitespace = (_b = to.match(/^\s*/)) === null || _b === void 0 ? void 0 : _b[0];
    (0, assert_1.default)(fromWhitespace !== undefined);
    (0, assert_1.default)(toWhitespace !== undefined);
    if (fromWhitespace === toWhitespace) {
        const adjuster = (s) => s;
        adjuster.desc = 'none';
        return adjuster;
    }
    const fromRe = new RegExp(`^${fromWhitespace}`);
    const adjuster = (s) => s.replace(fromRe, toWhitespace);
    adjuster.desc = `${fromWhitespace.length} -> ${toWhitespace.length}`;
    return adjuster;
}
class FileUpdateService {
    constructor(history) {
        this.history = history;
    }
    apply(fileUpdate) {
        return __awaiter(this, void 0, void 0, function* () {
            this.history.log(`[file-update] Applying file change to ${fileUpdate.file}  `);
            this.history.log(`[file-update] Original content:\n${fileUpdate.original}`);
            this.history.log(`[file-update] Modified content:\n${fileUpdate.modified}`);
            if (!(0, fs_1.existsSync)(fileUpdate.file)) {
                this.history.log(`[file-update] File does not exist: ${fileUpdate.file}`);
                yield (0, promises_1.writeFile)(fileUpdate.file, fileUpdate.modified, 'utf8');
                return undefined;
            }
            const fileContents = yield (0, promises_1.readFile)(fileUpdate.file, 'utf8');
            const fileLines = fileContents.split('\n');
            const originalLines = fileUpdate.original.split('\n');
            const match = findLineMatch(fileLines, originalLines);
            if (!match)
                return [`[file-update] Failed to find match for ${fileUpdate.file}.\n`];
            const [index, length] = match;
            const nonEmptyIndex = originalLines.findIndex((s) => s.trim());
            const adjustWhitespace = makeWhitespaceAdjuster(fileLines[index + nonEmptyIndex], originalLines[nonEmptyIndex]);
            this.history.log(`[file-update] Found match at line ${index + 1}, whitespace adjustment: ${adjustWhitespace.desc}\n`);
            fileLines.splice(index, length, ...fileUpdate.modified.split('\n').map(adjustWhitespace));
            yield (0, promises_1.writeFile)(fileUpdate.file, fileLines.join('\n'), 'utf8');
            return [`File change applied to ${fileUpdate.file}.\n`];
        });
    }
}
exports.default = FileUpdateService;
