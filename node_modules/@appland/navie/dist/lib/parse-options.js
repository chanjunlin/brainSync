"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserOptions = void 0;
const console_1 = require("console");
/* eslint-disable no-continue */
class UserOptions {
    constructor(options) {
        this.options = options;
    }
    has(key) {
        return this.options.has(key);
    }
    isEnabled(key, defaultValue) {
        return this.booleanValue(key, defaultValue);
    }
    numberValue(key, defaultValue) {
        if (!this.options.has(key))
            return defaultValue;
        const value = this.options.get(key);
        if (typeof value === 'string') {
            const numberValue = parseInt(value, 10);
            if (!Number.isNaN(numberValue))
                return numberValue;
        }
        return defaultValue;
    }
    booleanValue(key, defaultValue) {
        if (!this.options.has(key))
            return defaultValue;
        const value = this.options.get(key);
        if (typeof value === 'boolean')
            return value;
        return defaultValue;
    }
    stringValue(key, defaultValue) {
        if (!this.options.has(key))
            return defaultValue;
        const value = this.options.get(key);
        if (typeof value === 'string')
            return value;
        return defaultValue;
    }
    populateContextFilters(filters) {
        const exclude = this.stringValue('exclude');
        if (exclude)
            filters.exclude = [exclude];
        const include = this.stringValue('include');
        if (include)
            filters.include = [include];
        const types = this.stringValue('itemtype');
        if (types)
            filters.itemTypes = types.split(',').map((type) => type);
    }
}
exports.UserOptions = UserOptions;
function parseOptions(question) {
    // eslint-disable-next-line no-param-reassign
    question = question.trimStart();
    if (!question)
        return { options: new UserOptions(new Map()), question: '' };
    const options = new Map();
    const optionPattern = /^\/(?:[a-zA-Z0-9-]+)(?:=[^ ]+)?/;
    const words = question.split('\n')[0].split(' ');
    const restLines = question.split('\n').slice(1);
    const skippedWords = new Array();
    let i = 0;
    for (; i < words.length; i += 1) {
        const word = words[i];
        // Disregard command directives and empty words
        if (word.startsWith('@') || !word.trim()) {
            skippedWords.push(word);
            continue;
        }
        if (!optionPattern.test(word))
            break;
        const option = word.replace('/', '');
        let value;
        let key;
        const [keyStr, valueStr] = option.split('=');
        if (valueStr !== undefined) {
            key = keyStr;
            if (valueStr === 'true' || valueStr === 'yes' || valueStr === 'on')
                value = true;
            else if (valueStr === 'false' || valueStr === 'no' || valueStr === 'off')
                value = false;
            else
                value = valueStr;
        }
        else {
            // eslint-disable-next-line no-lonely-if
            if (keyStr.startsWith('no')) {
                key = keyStr.slice('no'.length);
                value = false;
            }
            else {
                key = keyStr;
                value = true;
            }
        }
        (0, console_1.warn)(`User option ${key}=${value.toString()}`);
        options.set(key.toLowerCase(), value);
    }
    const remainingQuestion = [[...skippedWords, ...words.slice(i)].join(' '), ...restLines].join('\n');
    return { options: new UserOptions(options), question: remainingQuestion };
}
exports.default = parseOptions;
